#pragma kernel CSMain

struct Triangle {
    float3 v0, v1, v2;
    float3 n0, n1, n2;
    float3 color;
    float smoothness;
    float metallic;
    float3 boundsMin;
    float3 boundsMax;
    float3 padding; 
};

struct Ray {
    float3 origin;
    float3 direction;
};

RWTexture2D<float4> Result;
StructuredBuffer<Triangle> _Triangles;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float3 _LightDirection;
int _TriangleCount;
int _MaxBounces;

// Fast AABB intersection (Slab method)
bool IntersectAABB(Ray ray, float3 minB, float3 maxB) {
    float3 t0 = (minB - ray.origin) / ray.direction;
    float3 t1 = (maxB - ray.origin) / ray.direction;
    float3 tmin = min(t0, t1);
    float3 tmax = max(t0, t1);
    float near = max(max(tmin.x, tmin.y), tmin.z);
    float far = min(min(tmax.x, tmax.y), tmax.z);
    return near <= far && far > 0;
}



float IntersectTriangle(Ray ray, Triangle tri, out float3 normal) {
    float3 edge1 = tri.v1 - tri.v0;
    float3 edge2 = tri.v2 - tri.v0;
    float3 h = cross(ray.direction, edge2);
    float a = dot(edge1, h);
    if (abs(a) < 0.0001f) return -1.0;
    float f = 1.0 / a;
    float3 s = ray.origin - tri.v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return -1.0;
    float3 q = cross(s, edge1);
    float v = f * dot(ray.direction, q);
    if (v < 0.0 || u + v > 1.0) return -1.0;
    float t = f * dot(edge2, q);
    if (t > 0.0001f) {
        float w = 1.0 - u - v;
        normal = normalize(tri.n0 * w + tri.n1 * u + tri.n2 * v);
        return t;
    }
    return -1.0;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    if (id.x >= width || id.y >= height) return;

    float2 uv = float2((id.xy + 0.5) / float2(width, height) * 2.0 - 1.0);

    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = normalize(mul(_CameraToWorld, float4(mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz, 0)).xyz);

    Ray ray; ray.origin = origin; ray.direction = direction;
    float3 finalColor = 0;
    float3 energy = 1.0;

    for (int bounce = 0; bounce < _MaxBounces; bounce++) {
        float tNearest = 1e30;
        float3 hitNormal = 0;
        int hitIndex = -1;

        for (int i = 0; i < _TriangleCount; i++) {
            // AABB Culling: Skips triangle math if ray misses the mesh bounds
            if (IntersectAABB(ray, _Triangles[i].boundsMin, _Triangles[i].boundsMax)) {
                float3 n;
                float t = IntersectTriangle(ray, _Triangles[i], n);
                if (t > 0 && t < tNearest) {
                    tNearest = t;
                    hitNormal = n;
                    hitIndex = i;
                }
            }
        }

        if (hitIndex != -1) {
            Triangle tri = _Triangles[hitIndex];
            ray.origin = ray.origin + ray.direction * tNearest;
            
            float diffuseFactor = max(0.1, dot(hitNormal, _LightDirection));
            float3 specularColor = lerp(float3(1, 1, 1), tri.color, tri.metallic);
            float3 diffuseColor = tri.color * (1.0 - tri.metallic);

            finalColor += diffuseColor * diffuseFactor * energy * (1.0 - tri.smoothness);
            energy *= specularColor * tri.smoothness;
            
            ray.direction = reflect(ray.direction, hitNormal);
            ray.origin += hitNormal * 0.001f;

            if (length(energy) < 0.05) break;
        } else {
            // Simple Skybox Gradient
            float3 skyColor = lerp(float3(0.01, 0.01, 0.02), float3(0.1, 0.2, 0.4), ray.direction.y * 0.5 + 0.5);
            finalColor += energy * skyColor;
            break;
        }
    }

    Result[id.xy] = float4(finalColor, 1.0);
}